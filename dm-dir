#!/bin/bash

set -o pipefail

[ ! "$(command -V "fzf")" ] || \
    [ ! "$(command -V "dmenu")" ] && exit 1

# TODO: REAL COMMANDLINE FLAG PARSER
[ -d "$1" ] && STARTING_PATH="$1" || exit 1

PROMPT="dmenu -p SELECT: -i -g 3 -l 15"
[ "$2" == "-t" ] && PROMPT="fzf"

SORT_ENTRIES=0
[ "$3" == "-s" ] && SORT_ENTRIES=1

CURRENT_PATH="$STARTING_PATH"
MAX_FIND_DEPTH=1
PATH_HISTORY=()
PATH_DEPTH=0
QUERY=""

# gets the content of CURRENT_PATH
path_content()
{
    # filetype of the thing to find
    local type="$1"

    if [ -n "$type" ]; then
        find -L "$CURRENT_PATH" -maxdepth "$MAX_FIND_DEPTH" -mindepth 1 -type "$type" -printf "%f\n"
    else
        find -L "$CURRENT_PATH" -maxdepth "$MAX_FIND_DEPTH" -mindepth 1 -printf "%f\n"
    fi
}

# reset PATH_HISTORY
reset_path_history()
{
    PATH_DEPTH=0
    PATH_HISTORY=()
}

# add path to PATH_HISTORY
append_to_path_history()
{
    PATH_DEPTH=$((PATH_DEPTH + 1))
    PATH_HISTORY+=("$1")
}

# go back in PATH_HISTORY
go_back_in_path()
{
    [ "$PATH_DEPTH" -gt 0 ] && PATH_DEPTH=$((PATH_DEPTH - 1))
    CURRENT_PATH="${PATH_HISTORY[$PATH_DEPTH]}"
}

# folders go before files
sorted_path_content()
{
    local files=("$(path_content "f")")
    local directories=("$(path_content "d")")

    local dir_content=()

    for dir in "${directories[@]}"; do
        [ -n "$dir" ] && dir_content+=("$dir")
    done

    for file in "${files[@]}"; do
        [ -n "$file" ] && dir_content+=("$file")
    done

    echo "${dir_content[@]}"
}

main()
{
    while(true); do

        # reset the history if the current path is the starting path
        [ "$PATH_DEPTH" -gt 0 ] && [ "$CURRENT_PATH" == "$STARTING_PATH" ] && reset_path_history

        # files or folders in CURRENT_PATH
        local directory_content=()

        # get the content of CURRENT_PATH
        if [ "$SORT_ENTRIES" -eq 1 ]; then
            directory_content=("$(sorted_path_content)")
        else
            directory_content=("$(path_content)")
        fi

        # if nothing was found in the CURRENT_PATH go back
        if [ -z "${directory_content[*]}" ]; then
            go_back_in_path
            continue
        fi

        QUERY="$(printf "%s\n" "${directory_content[@]}" | $PROMPT)"

        # exit if nothing was selected, and current path is the starting path
        [ -z "$QUERY" ] && [ "$CURRENT_PATH" == "$STARTING_PATH" ] && break

        # go back if nothing was selected
        if [ -z "$QUERY" ]; then
            go_back_in_path
            continue
        fi

        # break the loop if a file was selected, and output the path of the file
        if [ -f "$CURRENT_PATH/$QUERY" ]; then
            printf "%s\n" "$CURRENT_PATH/$QUERY" 2>/dev/null &
            break

        # if a directory is selected, go inside it
        elif [ -d "$CURRENT_PATH/$QUERY" ]; then

            # save the current path
            append_to_path_history "$CURRENT_PATH"

            # append to current path
            CURRENT_PATH="$CURRENT_PATH/$QUERY"

            continue
        fi

    done
}

main
